# О проекте

Этот проект реализует **хеш-таблицу с открытой адресацией**.

[Документация по заголовочному файлу](hash_table/documentation.md)

## Что такое хеш-таблица?

**Хеш-таблица** — это структура данных, которая используется для хранения и быстрого поиска пар «ключ-значение». Основной принцип работы основан на **хеш-функции**, которая преобразует ключ в индекс массива, где хранится соответствующее значение.

### Основные принципы работы

1. **Хеш-функция** вычисляет хеш-значение (обычно число) на основе ключа.
2. **Индекс в массиве** определяется на основе хеш-значения.
3. **Коллизии** (когда два разных ключа дают одинаковый хеш) разрешаются с помощью:
   - **Метода цепочек** (использование списков в ячейках).
   - **Открытой адресации** (поиск свободного места в массиве по определённому алгоритму пробирования).

---

## Методы пробирования в открытой адресации

В проекте реализованы **три основных метода пробирования**:

### **Линейное пробирование**
 - **Принцип**: Увеличиваем индекс массива на фиксированное значение (`+1, +2, +3…`).
 - **Плюсы**: Простая реализация, быстрый доступ при небольших нагрузках.
 - **Минусы**: Кластеризация (группировка занятых ячеек), что замедляет поиск.

**Формула линейного пробирования**:
```c
    index = (initial_index + offset) % hash_table->capacity;
```

---

### **Квадратичное пробирование**
 - **Принцип**: Увеличиваем индекс по квадратичной последовательности (`+1², +2², +3²…`).
 - **Плюсы**: Уменьшает кластеризацию по сравнению с линейным пробированием.
- **Минусы**: При неудачном выборе размера таблицы могут возникать ситуации, когда не удаётся найти свободную ячейку.

**Формула квадратичного пробирования**:
```c
    index = (index_index + offset * offset) % hash_table->capacity;
```

---

### **Двойное хеширование**
 - **Принцип**: Используется **вторая хеш-функция** для расчёта шага пробирования.
 - **Плюсы**: Хорошее распределение, меньше кластеризации.
 - **Минусы**: Медленнее линейного пробирования.

**Формула двойного хеширования**:
```c
    int hash1 = hash_table->hash_function(key, hash_table->capacity);
    int hash2 = 1 + (hash1 % (hash_table->capacity - 1));

    index = (hash1 + offset * hash2) % hash_table->capacity;
```

---

## **Как проверить эффективность методов пробирования?**

Вы можете самостоятельно убедиться в разнице между методами, запустив **тест производительности**:

Файл `test_of_speed_for_probing.h` содержит код, который:
 - Генерирует случайные ключи.
 - Заполняет таблицы с разными методами пробирования.
 - Измеряет время вставки, поиска и удаления элементов.

**Попробуйте и узнайте, какой метод пробирования работает быстрее в вашем случае!**

В моем случае, я не заметил значительной разницы в производительности между методами. Все результаты варьировались в пределах незначительной погрешности, которая могла быть вызвана случайным выбором ключей и нагрузкой на систему во время тестирования.